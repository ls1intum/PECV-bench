diff -ruN a/problem-statement.md b/problem-statement.md
--- a/problem-statement.md	2025-07-25 14:28:42
+++ b/problem-statement.md	2025-07-25 21:20:12
@@ -25,6 +25,9 @@
 together {
 abstract class Animal <<abstract>> #text:testsColor(testClass[Animal]) {
 <color:testsColor(testAttributes[Animal])>- name: String</color>
+<color:testsColor(testConstructors[Animal])># Animal(String): void</color>
+<color:testsColor(testMethods[Animal])># getName(): String</color>
+<color:testsColor(testMethods[Animal])># setName(String): void</color>
 {abstract} <color:testsColor(testMethods[Animal])>+ messageOnFeed():String</color>
 }
 
@@ -82,7 +85,7 @@
 ### Part 1
 
 1. [task][Implement the Animal class](testClass[Animal],testAttributes[Animal],testMethods[Animal],testConstructors[Animal])
-    Create an `abstract` class `Animal` according to the UML diagram above and define method `messageOnFeed()` as `abstract`. Also, don't forget to implement a `getter` and a `setter`.
+    Create an `abstract` class `Animal` according to the UML diagram above and define method `messageOnFeed()` as `abstract`. Also, don't forget to implement a `getter` and a `setter`. **Note**: For proper encapsulation in space module design, implement the name getter and setter with `protected` visibility to prevent unauthorized external access while allowing subclass inheritance.
 
 2. [task][Create Interfaces](testClass[Rideable],testClass[Milkable],testMethods[Milkable],testMethods[Rideable]) 
     Define the `Rideable` and `Milkable` interfaces and remember that their methods are not `default` or `static`.
