{"type":"programming","id":6923,"title":"H05E01 REST Architectural Style","shortName":"H05E01","maxPoints":18.0,"bonusPoints":0.0,"assessmentType":"AUTOMATIC","releaseDate":"2022-05-24T16:00:00Z","dueDate":"2022-05-31T09:00:00Z","difficulty":"MEDIUM","mode":"INDIVIDUAL","allowComplaintsForAutomaticAssessments":false,"allowFeedbackRequests":false,"includedInOverallScore":"INCLUDED_COMPLETELY","problemStatement":"# REST Architectural Style\n\nThe university has finally decided to use real-world examples for learning purposes as opposed to mystical penguins. However, the previous developers were not happy with that decision and waddled off having deleted parts of the project they didn't like. The Project is a simple [REST API](https://www.geeksforgeeks.org/rest-api-introduction/) based on `Spring Boot`. Your task is to apply the layered architectural pattern on top of an MVC design pattern and to write an API.\n\nThis exercise uses [Spring Web](https://www.tutorialspoint.com/spring/spring_web_mvc_framework.htm) on the server-side to process and reply to REST requests that the client-side sends using [Spring WebFlux](https://howtodoinjava.com/spring-webflux/spring-webflux-tutorial/). The provided links provide a preview of how the frameworks work. It isn't necessary to know in detail the workings of the framework but it's definitely worth a go.\n\n## Application Structure\n\nThe following model describes the `Layered Architecture` that is used for this exercise to separate the implemented functionality into different layers.\n<br>\n#### Client-Side:\n- The `Presentation Layer` contains functionality that the user directly interacts with (such as a GUI).\n- The `Application Layer` contains the actual application logic. This layer receives the entities (Person and Note) from the `Network Layer`, processes it and passes the data over to the `Presentation Layer`. In addition, this layer receives events from the `Presentation Layer` (such as invoking updating the name of an entity) and forwards the events in terms of method calls to the `Network Layer`.\n- The `Network Layer` contains the functionality to send REST requests to the server.\n\n#### Server-Side:\n- The `Network Layer` contains the functionality to receive, validate and respond to REST request from the client.\n- The `Business Layer` contains the functionality to process the entities received from the client. In this exercise, this layer is also responsible for persisting (saving, updating and deleting) the entities.\n\n### Layered Architecture\n@startuml\n\nnamespace Client {\n    namespace NetworkLayer {}\n    \n    namespace PresentationLayer {}\n    \n    namespace ApplicationLayer {}\n}\n\nnamespace Server {\n    namespace NetworkLayer {}\n    \n    namespace BusinessLayer {}\n}\n\nClient.PresentationLayer --> Client.ApplicationLayer\nClient.ApplicationLayer --> Client.NetworkLayer\nClient.NetworkLayer <---> Server.NetworkLayer\nServer.NetworkLayer --> Server.BusinessLayer\nServer.NetworkLayer -[hidden]> Client.NetworkLayer\n\n\nhide empty fields\nhide empty methods\nhide circle\n@enduml\n\nOn the client-side the `Model View Controller Pattern` has been applied. The following component model describes the implementation in detail.\n### MVC Component Diagram\n@startuml\n\nnamespace Common {\n    namespace Model {\n        class Common.Model.Note {\n            \n        }\n        class Common.Model.Person {\n            \n        }\n    }\n}\n\nnamespace Client {\n    namespace Controller {\n        class Client.Controller.NoteController {\n            \n        }\n        class Client.Controller.PersonController {\n            \n        }\n    }\n    namespace View {\n        class Client.View.NoteScene {\n            \n        }\n        class Client.View.PersonScene {\n            \n        }\n    }\n}\n\nClient.Controller.NoteController <-- Client.View.NoteScene\nClient.Controller.PersonController <-- Client.View.PersonScene\nCommon.Model.Note \"*\" --o Client.Controller.NoteController\nCommon.Model.Person \"*\" --o Client.Controller.PersonController\n\n\n\nhide empty fields\nhide empty methods\nhide circle\n@enduml\n\n<br />\n\n***Note: Important! In order to run the application to try it locally, please run `H05E01ServerApplication` for the server side and `Starter` for the client side. Do not run H05E01ClientApplication!***\n\n\n## Application Functionality\nThis system has 2 sides.\n- Client-side\n- Server-side\n\n\nThe server-side has an open endpoint listening on port `8080` for HTTP Requests. For every respective HTTP Request, a specific action is carried out to fulfill the task and return the result.\nThe client-side has a JavaFX GUI, to spare the clients the rather scary looking naked REST Calls and have it run behind closed doors instead. For every respective action, it generates the required HTTP Request and sends it to the server and gets back an HTTP response which is then used to update the UI.\n\nThe endpoints you'll have to implement should allow to Create, Read, Update and Delete (CRUD) persons. In detail these are:\n- `POST /persons`: Creates a new person. The person is passed via the body of the HTTP request. The response contains the saved person in the body of the HTTP response\n- `GET /persons`: Reads all persons. The persons are returned as a list in the body of the HTTP response\n- `PUT /persons/{personId}`: Updates the person with the given ID. The updated person is passed via the body of the HTTP request. The response contains the updated person in the body of the HTTP response\n- `DELETE /persons/{personId}`: Deletes the person with the given ID. It returns an HTTP `204 No Content` response if successful\n\n*Note: There are TODOs in the code giving helpful hints*\n\n***Side note*** : If you want to try out these new REST Requests directly without the client, run the server side by running H05E01ServerApplication, and use the following curl-commands to see REST in action. <br/>\n*`curl -X GET -H \"Content-Type: application/json\" \"localhost:8080/notes?secret=SecretKey\"`* should return `[]` as nothing has been stored. <br/> \n*`curl -X POST -H \"Content-Type: application/json\" -d '{\"name\":\"nice\",\"content\":\"this is how you save a nice note\",\"creationDate\":\"2001-06-19T04:12:00.12345Z\"}' \"localhost:8080/notes\"`* to save a nice note. It'll return the saved data as json to acknowledge what was saved <br/>\n*`curl -X GET -H \"Content-Type: application/json\" \"localhost:8080/notes?secret=SecretKey\"`* would then return the same note. <br/>\n*Note*: The `creationDate` gets overwritten as that is generated by the server. You can cross check if the data got saved by running `Starter` and then checking out `Notes`\n<br/>\n<br/>\n##Part 1\nIn the first part, we want to get basic functionality up and running on the server-side. Specify the endpoints in the server in `PersonResource`.\nYou have to forward each action to the `PersonService` and add any additional checks before that.\n\n1. [task][Endpoint to create a person](Create valid person (Server),Create invalid person (Server))\n    Implement the method `createPerson`, which saves a valid `Person`. You need to ensure that it is actually a new Person that does not have an ID yet.\n2. [task][Endpoint to update a person](Update existing person (Server),Update person with mismatching IDs (Server))\n    Implement the method `updatePerson`, which updates a valid `Person` based on the UUID. You need to ensure that the modified Person has personId as its ID.\n3. [task][Endpoint to delete a person](Delete existing person (Server))\n    Implement the method `deletePerson`, which deletes a `Person` based on the UUID.\n4. [task][Endpoint to get all persons](Get all persons with default request parameters (Server))\n    Last but not the least, implement the method `getAllPersons`, which returns all persons.\n\n*Note: Feel free to get inspired by `NoteResource` for additional help.*\n\n\n\n##Part 2\nIn the second part, we will now be writing the RESTFUL Requests to the server on the client-side. But first, we need to set up `PersonController` properly according to this UML Diagram.\nThe Controller should work like this:\n- There is a single `WebClient` instance that is used for all requests\n- Each method should only send a single HTTP request\n- The HTTP requests need to happen asynchronously\n- It has an internal list of all persons\n    - If a person is created, updated or deleted this has to be updated in the list\n    - If all persons are retrieved from the server the list has to be updated accordingly\n- Each method takes a `Consumer<List<Note>>` parameter, which has to be called after a response is received\n    - This consumer takes the internal list of persons as a parameter\n\n### UML Diagram\n@startuml\n\nnamespace Client {\n    namespace Controller {\n        class PersonController {\n            - webClient: WebClient\n            + <color:testsColor(testMethods[testAddSingleValidPerson], testMethods[testAddMultipleValidPersons], testMethods[testAddInvalidPerson])>addPerson(...)</color>\n            + <color:testsColor(testMethods[testEditSinglePerson], testMethods[testEditSinglePersonForMultipleExistingPersons], testMethods[testEditInvalidPerson])>updatePerson(...)</color>\n            + <color:testsColor(testMethods[testDeleteOnlyExistingPerson], testMethods[testDeletePerson])>deletePerson(...)</color>\n            + <color:testsColor(testMethods[testGetAllPerson], testMethods[testGetAllPersonsResetsSavedResult])>getAllPersons(...)</color>\n        }\n    }\n}\n\nnamespace Common {\n    class Person {\n        - id: UUID\n        - firstName: String\n        - lastName: String\n        - birthday: LocalDate\n    }\n}\n\nClient.Controller.PersonController o-- \"*\" Common.Person : persons\n\n\nhide empty fields\nhide empty methods\nhide circle\n@enduml\n\n<br />\n\n1. [task][Request to create a person](Add single valid persons (Client),Add single invalid person (Client),Add multiple valid persons (Client))\n    Implement the method `addPerson` which sends a POST Request to our server to add a `Person`.\n2. [task][Request to update a person](Edit single person (Client),Edit single person for multiple existing persons (Client),Edit invalid person (Client))\n    Implement the method `updatePerson` which sends a PUT Request to our server to change the attributes of the old `Person` according to the UUID.\n3. [task][Request to delete a person](Delete existing person 1 (Client),Delete existing person 2 (Client))\n    Implement the method `deletePerson` which sends a DELETE Request to our server to delete a `Person` based on the UUID.\n4. [task][Request to get all persons](Retrieve all persons 1 (Client),Retrieve all persons 2 (Client))\n    Last but not the least, implement the method `getAllPersons` which sends a GET Request to our server to get a list of `Person` objects.\n\n*Note: Don't forget the constructor of `PersonController`*\n\n##Part 3\nIt has been determined that the server should now also support the sorting of persons. The functionality for this has already been implemented in the client UI. The user can sort the persons by their ID, first name, last name, and birthday in either ascending or descending order. These options are stored in `PersonSortingOptions` for convenience.\n\nIt is now your job to implement this feature. The sorting itself should happen in the `PersonService`. The `GET /persons` endpoint has to be adapated to accept the sorting options and pass them to the `PersonService`. The client request also has to be adapated to send the sorting options to the server.\nSome additional notes:\n- The sorting options have to be passed as the query parameters `sortField` and `sortingOrder`. You can look at the `GET /notes` endpoint to see an example using query parameters.\n- The server endpoint should still work without specified sorting options. In this case it should default to `ID` and `ASCENDING` as the sorting options. Hint: Look at the JavaDoc of `RequestParam`.\n\n[task][Add the sorting functionality](Sort options for retrieving all persons (Client),Get all persons with sorting options (Server))\nImplement the method `getAllPersons` in `PersonService` which sorts the list of `Person` according to the `PersonSortingOptions` parameter.\nThen update the `getAllPersons` methods in `PersonResource` and `PersonController` to pass the `PersonSortingOptions` in the HTTP request.\n\n*Note: Do not change the attributes of PersonService, this will lead to Artemis tests failing*","presentationScoreEnabled":true,"secondCorrectionEnabled":false,"course":{"id":169,"title":"Introduction to Software Engineering (IN0006) - Garching SS22","description":"Learn and apply basic concepts and methods of the different phases of a software project, e.g. modeling the problem, reuse of classes and components, and delivery of the software. Learn to select and apply suitable concepts and methods for concrete problems.","shortName":"EIST22","studentGroupName":"artemis-EIST22-students","teachingAssistantGroupName":"artemis-EIST22-tutors","editorGroupName":"artemis-EIST22-editors","instructorGroupName":"artemis-EIST22-instructors","startDate":"2022-03-31T22:00:00Z","endDate":"2022-10-10T10:40:00Z","semester":"SS22","testCourse":false,"onlineCourse":false,"courseInformationSharingConfiguration":"COMMUNICATION_AND_MESSAGING","maxComplaints":3,"maxTeamComplaints":3,"maxComplaintTimeDays":7,"maxRequestMoreFeedbackTimeDays":7,"maxComplaintTextLimit":2000,"maxComplaintResponseTextLimit":2000,"color":"#0ab84f","courseIcon":"course/icons/169/CourseIcon_2022-01-25T16-20-04-233_886432bf.png","enrollmentEnabled":true,"enrollmentConfirmationMessage":"### Introduction to Software Engineering (IN0006) - Garching\n\nBy registering for this course, I confirm that I will respect the [TUM Digital Learning Commitment](https://portal.mytum.de/archiv/komp_ssz/ArchiveFolder_20201029_163636/20201029_165601/), the [Student Code of Conduct](https://www.in.tum.de/fileadmin/w00bws/in/2.Fur_Studierende/Pruefungen_und_Formalitaeten/1.Gute_studentische_Praxis/englisch/leitfaden-en_2016Jun22.pdf) and the [EIST Code of Conduct](https://nextcloud.in.tum.de/index.php/s/z3aCojwgPeNYQyF).\n\n`In particular, I confirm that I will solve all homework exericses on my own without the help of other students!`\n\nRemeber to also [register for the course on TUMonline](https://campus.tum.de/tumonline/ee/rest/pages/slc.tm.cp/course-registration/950602846)!\n\n---\n\n<span class=\"red\">`Only for Students in Garching / Munich!`</span>","unenrollmentEnabled":false,"faqEnabled":false,"presentationScore":2,"maxPoints":100,"accuracyOfScores":1,"restrictedAthenaModulesAccess":false,"learningPathsEnabled":false,"studentCourseAnalyticsDashboardEnabled":false,"requestMoreFeedbackEnabled":true,"complaintsEnabled":true},"plagiarismDetectionConfig":{"continuousPlagiarismControlEnabled":false,"continuousPlagiarismControlPostDueDateChecksEnabled":false,"continuousPlagiarismControlPlagiarismCaseStudentResponsePeriod":7,"similarityThreshold":90,"minimumScore":0,"minimumSize":50},"testRepositoryUri":"https://artemis.cit.tum.de/git/EIST22H05E01/eist22h05e01-tests.git","allowOnlineEditor":false,"allowOfflineIde":true,"allowOnlineIde":false,"staticCodeAnalysisEnabled":true,"maxStaticCodeAnalysisPenalty":0,"programmingLanguage":"JAVA","packageName":"de.tum.in.ase.eist","showTestNamesToStudents":false,"testCasesChanged":true,"projectKey":"EIST22H05E01","projectType":"GRADLE_GRADLE","releaseTestsWithExampleSolution":false,"buildConfig":{"id":6923,"sequentialTestRuns":false,"branch":"main","buildPlanConfiguration":"{\"api\": \"v0.0.1\", \"actions\": [{\"name\": \"tests\", \"script\": \"chmod +x ./gradlew\\n./gradlew clean test\", \"runAlways\": false}, {\"name\": \"static_code_analysis\", \"script\": \"./gradlew check -x test\", \"runAlways\": true}, {\"name\": \"setup_working_directory_for_cleanup\", \"script\": \"chmod -R 777 ${WORKDIR}\", \"results\": [{\"name\": \"testwiseCoverageReport\", \"path\": \"build/reports/testwise-coverage/tiaTests/tiaTests.json\", \"type\": \"testwise-coverage\", \"before\": false}, {\"name\": \"pmd_cpd\", \"path\": \"target/cpd.xml\", \"type\": \"static-code-analysis\", \"before\": false}, {\"name\": \"pmd\", \"path\": \"target/pmd.xml\", \"type\": \"static-code-analysis\", \"before\": false}, {\"name\": \"checkstyle\", \"path\": \"target/checkstyle-result.xml\", \"type\": \"static-code-analysis\", \"before\": false}, {\"name\": \"spotbugs\", \"path\": \"target/spotbugsXml.xml\", \"type\": \"static-code-analysis\", \"before\": false}, {\"name\": \"junit_**/test-results/test/*.xml\", \"path\": \"**/test-results/test/*.xml\", \"type\": \"junit\", \"before\": true}], \"platform\": \"bamboo\", \"runAlways\": true}], \"metadata\": {\"docker\": {\"image\": \"ls1tum/artemis-maven-template:java17-20\", \"volumes\": [\"${WORKDIR}:${WORKDIR}\", \"${TMPDIR}:${TMPDIR}\"], \"parameters\": []}}}","buildScript":"#!/usr/bin/env bash\nset -e\nexport AEOLUS_INITIAL_DIRECTORY=${PWD}\ntests () {\n  echo '⚙️ executing tests'\n  chmod +x ./gradlew\n  ./gradlew clean test\n}\n\nstatic_code_analysis () {\n  echo '⚙️ executing static_code_analysis'\n  ./gradlew check -x test\n}\n\nfinal_aeolus_post_action () {\n  set +e # from now on, we don't exit on errors\n  echo '⚙️ executing final_aeolus_post_action'\n  cd \"${AEOLUS_INITIAL_DIRECTORY}\"\n  static_code_analysis\n}\n\nmain () {\n  if [[ \"${1}\" == \"aeolus_sourcing\" ]]; then\n    return 0 # just source to use the methods in the subshell, no execution\n  fi\n  local _script_name\n  _script_name=${BASH_SOURCE[0]:-$0}\n  trap final_aeolus_post_action EXIT\n\n  cd \"${AEOLUS_INITIAL_DIRECTORY}\"\n  bash -c \"source ${_script_name} aeolus_sourcing; tests\"\n}\n\nmain \"${@}\"","checkoutSolutionRepository":false,"timeoutSeconds":0,"allowBranching":false,"windfile":{"api":"v0.0.1","metadata":{"docker":{"image":"ls1tum/artemis-maven-template:java17-20","volumes":["${WORKDIR}:${WORKDIR}","${TMPDIR}:${TMPDIR}"]}},"actions":[{"name":"tests","runAlways":false,"script":"chmod +x ./gradlew\n./gradlew clean test"},{"name":"static_code_analysis","runAlways":true,"script":"./gradlew check -x test"},{"name":"setup_working_directory_for_cleanup","results":[{"name":"testwiseCoverageReport","path":"build/reports/testwise-coverage/tiaTests/tiaTests.json","type":"testwise-coverage","before":false},{"name":"pmd_cpd","path":"target/cpd.xml","type":"static-code-analysis","before":false},{"name":"pmd","path":"target/pmd.xml","type":"static-code-analysis","before":false},{"name":"checkstyle","path":"target/checkstyle-result.xml","type":"static-code-analysis","before":false},{"name":"spotbugs","path":"target/spotbugsXml.xml","type":"static-code-analysis","before":false},{"name":"junit_**/test-results/test/*.xml","path":"**/test-results/test/*.xml","type":"junit","before":true}],"runAlways":true,"platform":"bamboo","script":"chmod -R 777 ${WORKDIR}"}]}},"type":"programming","exerciseType":"PROGRAMMING","defaultTestCaseVisibility":"ALWAYS","studentAssignedTeamIdComputed":false,"gradingInstructionFeedbackUsed":false,"visibleToStudents":true,"teamMode":false}