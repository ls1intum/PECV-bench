{
  "case_id": "new-data/ERA2021-P01-Raycasting-mit-Festkommazahlen/003",
  "issues": [
    {
      "description": "Return-type mismatch for ray_sphere_intersect: the header in the solution repository declares an int return type, while the implementation in the solution (and the header in the template repository) use/expect a bool. This creates a direct contradiction within the solution (declaration vs. definition) and also diverges from the template header. Such a mismatch can cause compilation/linkage errors or undefined behaviour and will confuse students about the correct API to implement/use.",
      "severity": "HIGH",
      "category": "METHOD_RETURN_TYPE_MISMATCH",
      "related_locations": [
        {
          "type": "TEMPLATE_REPOSITORY",
          "file_path": "example_program/src/ray_sphere_intersect.h",
          "start_line": 5,
          "end_line": 10
        },
        {
          "type": "SOLUTION_REPOSITORY",
          "file_path": "example_program/src/ray_sphere_intersect.h",
          "start_line": 5,
          "end_line": 10
        },
        {
          "type": "SOLUTION_REPOSITORY",
          "file_path": "example_program/src/ray_sphere_intersect.cpp",
          "start_line": 10,
          "end_line": 35
        }
      ],
      "suggested_fix": "Make the header declaration and the implementation agree on the return type. The simplest fix is to change the solution repository header declaration from 'int ray_sphere_intersect(...)' to 'bool ray_sphere_intersect(...)' so it matches the .cpp implementation and the template header. Alternatively, change the implementation to return int everywhere, but keeping 'bool' is consistent with the template and the implementation semantics."
    },
    {
      "description": "Symbol visibility/export mismatch for fix_vec_sub_asm in the solution assembly file: the template assembly file exports the symbol using 'global fix_vec_sub_asm', but the solution assembly file contains 'extern fix_vec_sub_asm' (in the data section). This deviates from other assembly files and from the template's exported symbol. If the symbol is intended to be provided by this assembly module (as in the template), declaring it 'extern' in the solution will prevent it from being exported and may cause linking failures or confusion about which module provides the symbol.",
      "severity": "MEDIUM",
      "category": "VISIBILITY_MISMATCH",
      "related_locations": [
        {
          "type": "TEMPLATE_REPOSITORY",
          "file_path": "assignment/fix_vec_sub.asm",
          "start_line": 10,
          "end_line": 12
        },
        {
          "type": "SOLUTION_REPOSITORY",
          "file_path": "assignment/fix_vec_sub.asm",
          "start_line": 10,
          "end_line": 12
        }
      ],
      "suggested_fix": "In the solution repository assembly file, export the symbol consistently (as in the template). Replace the 'extern fix_vec_sub_asm' declaration with 'global fix_vec_sub_asm' (or otherwise ensure the file declares the symbol as global/exported in the appropriate section). This aligns the solution with the template expectation and with how other assignment assembly files export their symbols."
    },
    {
      "description": "The sphere-intersection function ray_sphere_intersect is declared with inconsistent signatures/names across header and implementation files in the template and solution repositories. In the template, the header declares a bool-returning prototype (ray_sphere_intersect(..., const float radius)) while the implementation (.cpp) defines bool ray_sphere_intersect(..., const float radius2) (different parameter name). In the solution repository, the header declares an int return type for ray_sphere_intersect(..., const float radius) whereas the implementation defines a bool-returning function using parameter name radius2 and different parameter identifiers (origin vs. orig). These mismatches (return type and parameter identifier differences across headers and .cpp files / between template and solution) make it unclear which prototype students should follow and can cause confusion when mapping the conceptual operation \"sphere intersection test\" to the actual function to implement or call.",
      "severity": "MEDIUM",
      "category": "IDENTIFIER_NAMING_INCONSISTENCY",
      "related_locations": [
        {
          "type": "TEMPLATE_REPOSITORY",
          "file_path": "example_program/src/ray_sphere_intersect.h",
          "start_line": 5,
          "end_line": 10
        },
        {
          "type": "TEMPLATE_REPOSITORY",
          "file_path": "example_program/src/ray_sphere_intersect.cpp",
          "start_line": 10,
          "end_line": 16
        },
        {
          "type": "SOLUTION_REPOSITORY",
          "file_path": "example_program/src/ray_sphere_intersect.h",
          "start_line": 5,
          "end_line": 10
        },
        {
          "type": "SOLUTION_REPOSITORY",
          "file_path": "example_program/src/ray_sphere_intersect.cpp",
          "start_line": 10,
          "end_line": 16
        }
      ],
      "suggested_fix": "Standardize the function prototype and parameter names across headers and implementations in both template and solution. For example, pick a single, clear prototype and apply it everywhere:\n\nbool ray_sphere_intersect(const float *origin, const float *dir, const float *center, const float radius2);\n\n(Or, for clarity, rename the last parameter to radiusSquared: const float radiusSquared). Ensure both header (.h) and implementation (.cpp) use the same return type (bool) and identical parameter names so students can unambiguously locate and call/implement the intended function."
    }
  ]
}
