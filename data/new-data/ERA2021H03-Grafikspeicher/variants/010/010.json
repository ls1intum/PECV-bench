{
  "case_id": "new-data/ERA2021-H03-Grafikspeicher/010",
  "issues": [
    {
      "description": "The problem statement specifies strict 24-bit packing (3 bytes per pixel, no padding). Both the template and the solution treat pixels as 4 bytes (32-bit) when computing addresses and when loading/storing pixels. Concretely, the solution multiplies x by 4 and uses a row stride of 7680 (which is 1920*4), and it writes/reads 4 bytes via mov [addr], ecx / mov ecx, [addr]. This contradicts the exercise requirement of 3 bytes per pixel and will lead to incorrect addresses and corrupt neighboring pixels if students follow the solution or template code.",
      "severity": "HIGH",
      "category": "ATTRIBUTE_TYPE_MISMATCH",
      "related_locations": [
        {
          "type": "PROBLEM_STATEMENT",
          "file_path": "problem_statement.md",
          "start_line": 17,
          "end_line": 18
        },
        {
          "type": "TEMPLATE_REPOSITORY",
          "file_path": "template_repository/pixel.asm",
          "start_line": 15,
          "end_line": 16
        },
        {
          "type": "TEMPLATE_REPOSITORY",
          "file_path": "template_repository/pixel.asm",
          "start_line": 100,
          "end_line": 106
        },
        {
          "type": "SOLUTION_REPOSITORY",
          "file_path": "solution_repository/pixel.asm",
          "start_line": 76,
          "end_line": 84
        },
        {
          "type": "SOLUTION_REPOSITORY",
          "file_path": "solution_repository/pixel.asm",
          "start_line": 163,
          "end_line": 164
        },
        {
          "type": "SOLUTION_REPOSITORY",
          "file_path": "solution_repository/pixel.asm",
          "start_line": 157,
          "end_line": 162
        }
      ],
      "suggested_fix": "Adjust the address calculation and memory accesses to use 3 bytes per pixel. The general formula should be: address = display_start + (y * width + x) * 3, where width = 1920, so row_stride = 1920 * 3 = 5760 and pixel_offset = x * 3. In assembly: compute row_offset = y * 5760, pixel_offset = x * 3, then ESI = display_start + row_offset + pixel_offset. When storing the pixel, write only 3 bytes (not a 4-byte DWORD). For example, store the low 3 bytes of the color register by storing bytes at [addr], [addr+1], [addr+2] (using byte stores and shifts or rotates), or assemble a 24-bit value and store piecemeal. Update any multipliers (change 4 -> 3 and 7680 -> 5760) and replace mov [addr], ecx / mov ecx, [addr] (4-byte accesses) with correct 3-byte read/write sequences so neighboring pixels are not corrupted."
    },
    {
      "description": "The template (and solution) reserve the display buffer as 'display_start RESD 8294400'. RESD reserves 4-byte words; the count chosen and the directive usage are inconsistent with the problem's described buffer size (1920×1080 pixels × 3 bytes/pixel = 6,220,800 bytes). Using RESD with count 8294400 leads to an incorrect allocation unit/size and will confuse students about the intended memory layout and capacity.",
      "severity": "MEDIUM",
      "category": "ATTRIBUTE_TYPE_MISMATCH",
      "related_locations": [
        {
          "type": "TEMPLATE_REPOSITORY",
          "file_path": "template_repository/pixel.asm",
          "start_line": 20,
          "end_line": 22
        },
        {
          "type": "SOLUTION_REPOSITORY",
          "file_path": "solution_repository/pixel.asm",
          "start_line": 4,
          "end_line": 6
        },
        {
          "type": "PROBLEM_STATEMENT",
          "file_path": "problem_statement.md",
          "start_line": 17,
          "end_line": 18
        }
      ],
      "suggested_fix": "Allocate the buffer in bytes with the correct total size for 24-bit pixels. For example: 'display_start RESB 6220800' (6220800 = 1920 * 1080 * 3). If you prefer word/dword allocation, compute the correct count and directive (e.g., RESD 1555200 would reserve 1,555,200 dwords which equals 6,220,800 bytes), and document the chosen unit so students are not misled by the allocation directive."
    },
    {
      "description": "The problem statement consistently refers to the color value as \"RGB\" (e.g. \"RGB-Wert im Register ecx\"), while both the template and the solution use the misspelled string \"RBG\" in the user prompt (get_color). This is an unintended naming/term mismatch for the same concept (Red/Green/Blue color value) and may cause a small amount of confusion for students when they read the prompt versus the specification.",
      "severity": "LOW",
      "category": "IDENTIFIER_NAMING_INCONSISTENCY",
      "related_locations": [
        {
          "type": "PROBLEM_STATEMENT",
          "file_path": "problem_statement.md",
          "start_line": 30,
          "end_line": 31
        },
        {
          "type": "TEMPLATE_REPOSITORY",
          "file_path": "template_repository/pixel.asm",
          "start_line": 28,
          "end_line": 28
        },
        {
          "type": "SOLUTION_REPOSITORY",
          "file_path": "solution_repository/pixel.asm",
          "start_line": 12,
          "end_line": 12
        }
      ],
      "suggested_fix": "Correct the typo in the prompt strings in the template and solution from \"RBG\" to \"RGB\" (e.g. change get_color to: db \"Bitte RGB-Wert für neue Farbe eingeben\", 10, 0) so the displayed prompt matches the problem statement terminology."
    }
  ]
}
